using System;
using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Xamarin.Macios.Generator.Context;
using Xamarin.Macios.Generator.Extensions;

namespace Xamarin.Macios.Generator.Emitters;

public class ClassEmitter : ICodeEmitter<ClassDeclarationSyntax> {

	ClassBindingContext _context;
	TabbedStringBuilder _builder;

    public string SymbolName => _context.SymbolName; 

	public ClassEmitter (ClassBindingContext? context, TabbedStringBuilder builder)
	{
		_context = context ?? throw new ArgumentNullException (nameof (context));
		_builder = builder;
	} 

	public void Emit ()
	{
		_builder.AppendLine ("// <auto-generated/>");
		_builder.AppendLine ("using System;");
		_builder.AppendLine ("using System.Drawing;");
		_builder.AppendLine ("using System.Diagnostics;");
		_builder.AppendLine ("using System.ComponentModel;");
		_builder.AppendLine ("using System.Threading.Tasks;");
		_builder.AppendLine ("using System.Runtime.Versioning;");
		_builder.AppendLine ("using System.Runtime.InteropServices;");
		_builder.AppendLine ("using System.Diagnostics.CodeAnalysis;");
		_builder.AppendLine ("using ObjCRuntime;");
		_builder.AppendLine ();
		_builder.AppendFormatLine ("namespace {0};", _context.Namespace);
		_builder.AppendLine ();
		// only register the class if it is not static
		if (!_context.IsStatic) {
			_builder.AppendFormatLine ("[Register(\"{0}\", true)]", _context.SymbolName);
		}

		_builder.AppendFormatLine ("public unsafe {0}partial class {1}",
			_context.IsStatic ? "static " : string.Empty,
			_context.SymbolName);

		using (var classBlock = _builder.CreateBlock (isBlock: true)) {
			// generate the class handle only for not static classes
			if (!_context.IsStatic) {
				classBlock.AppendGeneratedCodeAttribute ();
				classBlock.AppendFormatLine (
					"static readonly NativeHandle class_ptr = Class.GetHandle (\"{0}\");",
					_context.RegisterName);

				classBlock.AppendLine ();
			}

			// generate the default constructors only if they are not disabled or the class is not static
			if (!_context.IsStatic) {
				DefaultConstructorEmitter.RenderDefaultConstructor (classBlock, _context.SymbolName);
				classBlock.AppendLine ();
				DefaultConstructorEmitter.RenderSkipInit (classBlock, _context.SymbolName);
				classBlock.AppendLine ();
				DefaultConstructorEmitter.RenderNativeHandlerConstructor (classBlock,
					_context.SymbolName);
			}

			// generate the methods
			var methodEmitter = new MethodEmitter (_context, classBlock);
			var methods = _context.Symbol.GetMembers ().OfType<IMethodSymbol> ();
			foreach (var methodSymbol in methods) {
				methodEmitter.Emit (methodSymbol);
			}

			// generate the properties, order them by name to make the output deterministic
			var propertyEmitter = new PropertyEmitter (_context, classBlock);
			if (_context.Symbol.TryGetProperties (out var fields,
					out var boundProperties, out var diagnostics)) {
				if (!propertyEmitter.TryEmit (fields.Value, out var propertyDiagnostics)) {
				}

				if (!propertyEmitter.TryEmit (boundProperties.Value, out var boundPropertyDiagnostics)) {
				}
			} else {
				// TODO: diagnostics
			}
		}

	}

	public bool TryValidate ([NotNullWhen (false)] out ImmutableArray<Diagnostic>? diagnostics)
	{
		//TODO: check is props have right data, etc
		//get class w attributes, ensure attrs are being used correctly
		diagnostics = null;
		return true;
	}
}
