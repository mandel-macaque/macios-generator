using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Xamarin.Macios.Generator.Context;
using Xamarin.Macios.Generator.Emitters;
using Xamarin.Macios.Generator.Extensions;

namespace Xamarin.Macios.Generator;

/// <summary>
/// Source generator that writes the code needed for the export of a given selector in a class. This
/// generator does not provide the attributes but relies on those from the xamarin-macios project, this way
/// we can maintain API compatibility and remove the need of a two step compilation.
/// </summary>
[Generator]
public class BindingSourceGenerator : IIncrementalGenerator {
	// The following attribute is a copy of the BasetypeAttribute from the xamarin-macios project, this attribute
	// is part of bgen, but instead we would want to expose itby the generator.
	private const string BaseTypeAttributeSourceCode = @"// <auto-generated/>

namespace Foundation 
{
    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Enum)]
    public class BindingTypeAttribute : System.Attribute
    {
        public string Name { get; set; }
        public Type [] Events { get; set; }
        public string [] Delegates { get; set; }
        public bool Singleton { get; set; }

        // If set, the code will keep a reference in the EnsureXXX method for
        // delegates and will clear the reference to the object in the method
        // referenced by KeepUntilRef.   Currently uses an ArrayList, so this
        // is not really designed as a workaround for systems that create
        // too many objects, but two cases in particular that users keep
        // trampling on: UIAlertView and UIActionSheet
        public string KeepRefUntil { get; set; }
    }
}";

	private const string NotificationAttributeSourceCode = @"// <auto-generated/>
namespace Foundation 
{
    [AttributeUsage (AttributeTargets.Property, AllowMultiple = true)]
    public class NotificationAttribute : Attribute {
        public NotificationAttribute (Type t) { Type = t; }
        public NotificationAttribute (Type t, string notificationCenter) { Type = t; NotificationCenter = notificationCenter; }
        public NotificationAttribute (string notificationCenter) { NotificationCenter = notificationCenter; }
        public NotificationAttribute () { }

        public Type Type { get; set; }
        public string NotificationCenter { get; set; }
    }
}
";

	public void Initialize (IncrementalGeneratorInitializationContext context)
	{
		// Add the binding generator attributes to the compilation. This are only available when the
		// generator is used, similar to how bgen works.
		context.RegisterPostInitializationOutput (ctx => ctx.AddSource (
			"BindingTypeAttribute.g.cs",
			SourceText.From (BaseTypeAttributeSourceCode, Encoding.UTF8)));

		context.RegisterPostInitializationOutput (ctx => ctx.AddSource (
			"NotificationAttribute.g.cs",
			SourceText.From (NotificationAttributeSourceCode, Encoding.UTF8)));

		// Register to the compilation and listen for the classes that have the [BindingType] attribute.
		var classProvider = context.SyntaxProvider
			.CreateSyntaxProvider (
				static (s, _) => s is ClassDeclarationSyntax,
				(ctx, _) => GetDeclarationForSourceGen<ClassDeclarationSyntax> (ctx))
			.Where (t => t.BindingAttributeFound)
			.Select ((t, _) => t.Declaration);

		context.RegisterSourceOutput (context.CompilationProvider.Combine (classProvider.Collect ()),
			((ctx, t) => GenerateCode<ClassDeclarationSyntax> (ctx, t.Left, t.Right)));

		// same process for enums
		var enumProvider = context.SyntaxProvider
			.CreateSyntaxProvider (
				static (s, _) => s is EnumDeclarationSyntax,
				(ctx, _) => GetDeclarationForSourceGen<EnumDeclarationSyntax> (ctx))
			.Where (t => t.BindingAttributeFound)
			.Select ((t, _) => t.Declaration);

		context.RegisterSourceOutput (context.CompilationProvider.Combine (enumProvider.Collect ()),
			((ctx, t) => GenerateCode<EnumDeclarationSyntax>(ctx, t.Left, t.Right)));
	}

	static (T Declaration, bool BindingAttributeFound) GetDeclarationForSourceGen<T> (GeneratorSyntaxContext context)
		where T : BaseTypeDeclarationSyntax
	{
		var classDeclarationSyntax = (T) context.Node;

		// Go through all attributes of the class.
		foreach (AttributeListSyntax attributeListSyntax in classDeclarationSyntax.AttributeLists)
		foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes) {
			if (context.SemanticModel.GetSymbolInfo (attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
				continue; // if we can't get the symbol, ignore it

			string attributeName = attributeSymbol.ContainingType.ToDisplayString ();

			// Check the full name of the [Binding] attribute.
			if (attributeName == AttributesNames.BindingAttribute)
				return (classDeclarationSyntax, true);
		}

		return (classDeclarationSyntax, false);
	}

	void GenerateCode <T> (SourceProductionContext context, Compilation compilation,
		ImmutableArray<T> classDeclarations) where T : BaseTypeDeclarationSyntax
	{

		var bindingContext = new RootBindingContext (compilation);
		foreach (var classDeclarationSyntax in classDeclarations) {
			var semanticModel = compilation.GetSemanticModel (classDeclarationSyntax.SyntaxTree);
			if (semanticModel.GetDeclaredSymbol (classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
				continue;

			var sb = new TabbedStringBuilder (new());
			var classBindingContext = ContextFactory.Create<T> (bindingContext, semanticModel,
				classSymbol, classDeclarationSyntax);
			var emitter = EmitterFactory.Create<T> (classBindingContext, sb);

			if (!emitter.TryValidate (out var diagnostics)) {
				continue;
			}
			emitter.Emit ();

			var code = sb.ToString ();
			context.AddSource ($"{emitter.SymbolName}.g.cs", SourceText.From (code, Encoding.UTF8));
		}
	}
}
